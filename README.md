_Прочете първо  : [Розетски камък на КТ](Rosetta.md)_

## Част1: Защо да изучаваме теория на категориите?
Теорията на категориите се счита от мнозина за сложна тема. Тя се превръща в основа за обединяване на интердисциплинарни математически идеи и начинът, по който постига това, е чрез заемане на абстрактна гледна точка върху обекти, взаимоотношения, състояния, събития, процеси и траектории на тези дисциплини. Това ниво на абстракция действа като основа за разсъждения именно върху широк спектър от модели, случващи се в различни области, чрез изготвяне на строги аналогии между тях.
![rosetta-stone](https://github.com/user-attachments/assets/9827cb6a-4bd4-4bdc-a475-4292f4435223)

Тази абстрактна гледна точка е едновременно сила и слабост на подхода. Абстрактният характер на темата я прави много мощна, като ѝ дава общността да обединява много различни области на изследване, като например алгебрична топология, теория на вероятностите, реален анализ, функционален анализ, теория на числата, комбинаторика и изчисления. Но в същото време тази абстрактна природа означава, че е доста трудно да се ориентираме в конкретни теми на изследване. Това затруднява изясняването им, без първо да се научи достатъчно терминология и разбиране, за да се създаде рамка за дискурс за изучаваната дисциплина.


### Материали за Теория на категориите.

Тук ще помествам някои помагала , предназначени да ви въведат в Теория на категориите. 
Ще започнем с един преговор на необходимата математика: Вектори, скалари,матрици и т.н. 
[Линейна алгебра](https://immersivemath.com/ila/index.html) 
Ако не ви се занимава с линейна алгербра, то един [Преговор на "Функции"](https://bg.khanacademy.org/math/algebra-home/alg-functions) би освежил паметта от ученическия период. 


![Свойства на векторната аритметика](https://github.com/user-attachments/assets/399a775d-e3e3-4fd3-a5c6-a2d963bd6653)


Ако ви интересува малко предистория, можете да се запознаете и с това четиво:
[На групи и Монади](ToGroupsAndMonads.md)

# Увод

Традиционно **теорията на множествата** се смяташе за основа на математиката, въпреки че напоследък **теория на типовете** се бори за тази титла. В известен смисъл теорията на множествата е езикът асемблер на математиката и като такъв съдържа много детайли за имплементацията, които често замъгляват представянето на идеи от високо ниво.
Теорията на категориите не се опитва да замени теорията на множествата и често се използва за изграждане на абстракции,които по-късно се моделират с помощта на множества. Всъщност фундаменталната теорема на теорията на категориите, ***Yoneda lemma*** , свързва категориите с техните модели в теорията на множествата. Можем да намерим полезна интуиция в компютърната графика, където изграждаме и манипулираме абстрактни светове, само за да ги проектираме и изпробваме на цифров дисплей в последния момент.
Не е необходимо да владеете свободно теория на множествата, за да изучавате теория на категориите. Но е необходимо известно познаване на основите. Например идеята, че множествата съдържат елементи. Казваме, че ако е дадено множество **S** и елемент **a**, има смисъл да се запитаме дали ***a*** е елемент на **S** или не.
Важно свойство на елементите на едно множество е, че могат да бъдат сравнени за равенство.

Дадени два елемента ***x ∈ A*** и ***y ∈ A***, можем да питаме: **равен ли е x на y**?

Или можем да наложим условието **x = y**, в случай че **x** и **y** са резултати от две различни рецепти за избиране на елементи на множеството **A**.Равенството на елементи от множество е 
същността на всички комутативни диаграми в теория на категориите.
[Декартовото произведение](https://bg.wikipedia.org/wiki/%D0%94%D0%B5%D0%BA%D0%B0%D1%80%D1%82%D0%BE%D0%B2%D0%BE_%D0%BF%D1%80%D0%BE%D0%B8%D0%B7%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5) на две множества ***A × B*** се определя като множеството от всички двойки **⟨a, b⟩**, такива че ***a ∈ A и b ∈ B***.

Функция **f : A → B**, от изходното множество, наречено **домейн на f**, към целевото множество, наречено **кодомейн**, също се определя като множество от двойки. Това са двойките от вида ⟨a, b⟩, където **b = f a**. Тук b е резултатът от действието на функцията f върху аргумента a. Може би ви е по-познат записът f(a) за прилагане на функция, но тук ще следваме **Haskell**-конвенцията да се изпускат скобите (и запетаите при функции с много аргументи).

В програмирането сме свикнали функциите да се дефинират чрез последователност от инструкции. Даваме аргумент a и прилагаме инструкциите, за да произведем резултата b. Често се тревожим колко време ще отнеме смятането или дали алгоритъмът въобще приключва.

В математиката приемаме, че за всеки аргумент **a ∈ A** резултатът **b ∈ B** е наличен незабавно и че е уникален. В програмирането наричаме такива функции чисти и тотални.
Един обект се определя от неговите връзки.
**Стрелката** е доказателство, свидетелство за факта, че два обекта са свързани. Понякога няма доказателство, обектите са несвързани; понякога има много доказателства; а понякога има само едно доказателство - уникална стрелка между два обекта.

## Какво означава да си уникален?

**"Уникална стрелка"** означава: ако някой твърди, че има две различни стрелки с едни и същи начална и крайна точка ... се оказва, че те всъщност са една и съща. **Уникална означава единствената възможна.**
Това означава, че ако можете да намерите две от тях, тогава те трябва да са равни. Обект, който има уникална **изходяща** стрелка към всеки обект, се нарича **НАЧАЛЕН ОБЕКТ**.
Неговият двойник е обект, който има уникална **входяща** стрелка от всеки обект. Той се нарича **ТЕРМИНАЛЕН ОБЕКТ**.

В математиката началният обект често се обозначава с **0**, а терминалният обект с **1**.

**Стрелката от 0 към всеки обект се обозначава с ¡**.

**Стрелката от всеки обект към 1 се обозначава с !**.

**Началният обект** е източникът на всичко! Като тип е известен в **Haskell** като **Void**.
Той символизира хаоса, от който произлиза всичко. Тъй като има стрелка от **Празнотата (Void)** към всичко, **има и стрелка от Празнотата (Void) към самата нея**. Така Void поражда Void и всичко останало.

**Терминалният обект** обединява всичко. Като тип е известен като **()**. Той символизира крайния ред.
В логиката, терминалният обект означава крайната истина, символизирана от **⊤** (True). Фактът, че има стрелка към него от всеки обект, означава, че **⊤ **е **True**, независимо какви са вашите предположения.

**Началният обект** означава логическа лъжа, противоречие или контрафактуална ситуация. Той се пише като **False** и се символизира от обърнатото T, **⊥**. Фактът, че има стрелка от него към всеки обект, означава, че можете да докажете всичко, започвайки от неверни предпоставки. В Haskell има безкрайно много типове и към всеки един от тях има уникална функция/стрелка от Void.
Всички тези функции са известни под едно и също име: **absurd**.

<img width="546" height="182" alt="image" src="https://github.com/user-attachments/assets/a2b1022e-14d1-4211-9148-f694c0be144a" />


В Haskell името на терминалния тип е **()**, чифт празни скоби, произнасящи се **Unit**.

### Терминалният обект като „идеалната точка".  

Tерминалният обект е толкова прост, че има само едно свойство: че съществува. Нищо друго не може да се прави с него. Той е просто там. И от всеки друг обект има **точно една стрелка към него: „един начин да го достигнеш"**.
Това е като идеална математическа точка: няма размер, няма цвят, няма структура. Как използваме тази „точка" за да разглеждаме други обекти?

**Ето хитростта:**

Ако имаме стрелка от терминалния обект към друг обект **A**,това е като да избереш един елемент на **A**.

**Защо?**

Защото терминалният обект има само една стойност, наричаме я **()**. Така че всяка функция **() -> A** трябва да вземе **()** и да върне някаква **стойност от A**. Тоест тази функция е просто избор: **„кой елемент на A да върна?"**. И ако има много такива функции, това означава, че A има много елементи, много възможни избори.

_Да го преведем в пример с живота:_

_Да си представим, че терминалният обект е дете, което знае само да посочва с един пръст, например показалеца.
То няма други възможности: каквото и да го питаме, то може да направи само едно движение, вдига пръста си и посочва.
Как работи това за друг обект?_
_Да кажем, че имаме:
Обект A = кошница с ябълки и круши. Стрелката () → A е като да накараме детето да посочи едно нещо от кошницата. Тъй като детето може да прави само едно движение (посочва с пръста), единственото, което определя стрелката, е кое нещо е посочено от пръста. Тоест, ако има 5 плода в кошницата, има 5 възможни стрелки () → A: показалецът сочи първото, второто, третото, четвъртото, петото._

Ако A е празно - няма стрелки.
Ако A има 1 елемент - има точно 1 стрелка.
Ако A има много елементи - има много стрелки.

Стрелките от терминалния обект към A „сканират" елементите на A. Те разкриват структурата му. Ако има много стрелки, значи A има много „точки". Ако има една стрелка, A има една „точка". Ако няма - A е празен (няма елементи).

Това в Haskell изглежда така:

**() → A** е функция, която избира точно една стойност от A.

**pickFirst :: () -> Int**

**pickFirst () = 42**

Такива функции има толкова стойности, колкото стойности има в A.Ето как терминалният обект се превръща в „сонда", която проверява какъв е A.

Да го съберем в едно изречение:

Терминалният обект е идеалната точка без структура. Стрелките от него към даден обект A са като да сочиш „една особеност/точка/стойност" на A. Колкото повече такива стрелки има, толкова по-богата е структурата на A.

**„Глобален елемент" - какво е това ?**

Казваме, че **x е глобален елемент на A**, ако има стрелка **от терминалния обект 1 към A**:

**1 → A**

Това просто означава:

x е един конкретен елемент на A.Точка.

В категорията стрелките от 1 към A играят ролята на **„избор на елемент"**.

В типовата теорията **x : A** означава:
**x е стойност от тип A.**

В **Haskell** пишем:

**x :: A**

**Главни букви → конкретни типове (Int, Bool)**
**Малки букви → типови променливи (a, b)**

**Връзката между типове и категории:**

Категорийно погледнато, **x :: A **се тълкува така:
**x е стрелка от () към A**:

**() -> A**

Тоест "ако ми дадеш единствената стойност **()**, аз ти връщам **един** елемент на A".
Така че стойността x е всъщност функция, която избира един елемент на A.

В логиката

Стрелката 1 → A отговаря на логическото твърдение:
True → A
А това е просто „ако True е вярно, тогава A е вярно". В логиката функцията 1 → A е доказателство, че A е вярно.
_(И може да има различни доказателства → различни функции → различни елементи.)_

**Void и защо е празен?**

Понеже в нашия контекст няма стрелки към **Void** от никакъв тип (така сме го дефинирали), то няма и **1 → Void**.
А ако няма **1 → Void**, значи **Void няма елементи**. Затова казваме, че **Void е празен тип**.
Терминалният обект **(1)** има точно един елемент, защото има точно една стрелка **1 → 1.** Точно толкова, колкото и стойност има типът () в Haskell:

една единствена (()).

Затова 1 го наричаме **singleton** - едноелементен/ сингълтон.

_Забележка накрая_

_В общата категорийна теория няма правило, че началният обект (Void) не може да има входящи стрелки.
Но в картезианско затворени категории (като категорията на типовете в Haskell) това е задължително:
празният тип не може да има елементи, следователно не може да има стрелка 1 → Void._

Всичко това в едно изречение

Ако можем да направим функция () -> A, това е един елемент на A. Ако не можем - A е празен.
Ако можем да направим само една такава функция - A има точно един елемент.

------

В теорията на категориите казваме, че **x е глобален елемент на A**, ако това е стрелка:

**1 → A**.

Често просто ще го наричаме елемент (пропускайки „глобален"). В теорията на типовете **x : A** означава, че **x е от тип A**. 

В **Haskell** използваме синтаксиса с двойното двоеточие:

**x :: A**

_(Haskell използва имена с главни букви за конкретни типове и малки букви за типовите променливи.)_


Забележете, че може да има много различни доказателства за A. Понеже сме постановили, че няма стрелки от никой друг обект към Void, няма и стрелка от терминалния обект към него. Следователно Void няма елементи. Затова го считаме за празен. Терминалният обект има точно един елемент, тъй като има уникална стрелка от него към самия него, 1 → 1. Затова понякога го наричаме едноелементен (singleton).

_Забележка: В теорията на категориите няма забрана началният обект да има входящи стрелки от други обекти. Но в картезианско затворените категории, които разглеждаме тук, това не е позволено._

## Вместо край на Част 1
Когато в една категория вземем двa произволни обектa, всички стрелки между тях образуват **множество**. Точно затова е добре човек да има поне базова представа от теория на множествата — тя подпомага интуицията ни за категориите.
В **Haskell** бихме написали:

**f :: a -> b**

Това изречение казва само едно: _„f е функция от тип от a към b“_. А **a -> b**  тук е просто името, което даваме на този тип.
Сега, ако искаме функционалните типове да стоят с всички останали типове, трябва да имаме обект, който представлява „множеството от стрелки от a към b“.
Но за да опишем напълно такъв обект, трябва да уточним как той се свързва с останалите обекти в категорията — най-вече с a и b. Инструментите за това идват по-късно. Ще стигнем и до там.
Засега е важно просто да държим в главата едно разграничение:

Стрелките от a към b образуват множество (колекция).

Но в категориите имаме и обект, който символизира „обекта на стрелките“ — този обект наричаме **експоненциал** и го записваме като _ba_

Елемент на експоненциалния обект _ba_ е стрелка, която идва от терминалния обект **()** към този експоненциал. Тоест това е един начин да „кодираме“ функция като точка в един обект.

И тук идва фината част: програмистката нотация замазва това разграничение: a -> b изглежда като едновременно и стрелка, и обект. В категорията обаче ги държим отделно: самата стрелка е едно нещо, експоненциалният обект е друго.

Когато в Haskell пишем:

**f :: a -> b**

В категорията това би било по-близо до елемент на експоненциалния обект _ba_

В логиката, стрелката → е импликация: тя твърди факта, че „ако A, то B“. Експоненциален
обект е съответното твърдение. Може да е вярно или може да е невярно, не знаем.
Трябва да го докажете. 
Разгледайте  твърдението „Ако желанията бяха коне, просяците щяха да яздят“ - разгледайте го като
обект. Това не е празен обект, защото можете да посочите доказателство за това – нещо от рода на: „Човек, който има кон, го язди. Просяците имат желания. Тъй като желанията са коне, просяците имат коне. Следователно просяците яздят.“ Но дори и да имате доказателство за това твърдение, то е безполезно за вас, защото никога не можете да докажете неговата предпоставка: „желание = кон“.

[Част 2: Композиция](Composition.md)


